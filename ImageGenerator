import csv
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.colors import ListedColormap, Normalize
from scipy.ndimage import gaussian_filter

def generate_initial_landscape(rows, cols):
    ranges = {
        'eau': (1, 2), #bleu foncé
        'terre': (2, 4), # vert foncé
        'plateau': (5, 6), # orange
        'montagne': (5, 8), # marron
    }

    proportions = {
        'eau': 0.2,
        'terre': 0.3,
        'plateau': 0.2,
        'montagne': 0.2,
    }

    landscape_matrix = np.zeros((rows, cols), dtype=int)

    for key, (low, high) in ranges.items():
        num_elements = int(proportions[key] * rows * cols) # nombre d'éléments de chaque type
        elements = np.random.randint(low, high +5, num_elements) 
        flat_indices = np.random.choice(rows * cols, num_elements, replace=False) 
        landscape_matrix.flat[flat_indices] = elements

    remaining_elements = np.where(landscape_matrix == 0) 
    remaining_values = np.random.randint(1, 4, remaining_elements[0].size) 
    landscape_matrix[remaining_elements] = remaining_values 

    return landscape_matrix

def smooth_landscape(landscape_matrix, sigma=1):
    smoothed_landscape = gaussian_filter(landscape_matrix.astype(float), sigma=sigma)
    return smoothed_landscape.astype(int)

def final_landscape(landscape_matrix, iterations=5):
    rows, cols = landscape_matrix.shape
    new_landscape = landscape_matrix.copy()

    for _ in range(iterations):
        for i in range(1, rows-1):
            for j in range(1, cols-1):
                neighborhood = landscape_matrix[i-1:i+2, j-1:j+2].flatten()
                most_common = np.bincount(neighborhood).argmax()
                new_landscape[i, j] = most_common

        landscape_matrix = new_landscape.copy()

    return new_landscape

def save_landscape_to_csv(landscape, filename):
    with open(filename, 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerows(landscape)

def plot_landscape_3d(landscape):
    x = np.arange(landscape.shape[0])
    y = np.arange(landscape.shape[1])
    x, y = np.meshgrid(x, y)
    z = landscape

    #Définition de la colormap et de la normalisation
    cmap = ListedColormap(['darkblue','blue','green', 'darkgreen', 'orange', 'brown', 'red'])
    norm = Normalize(vmin=z.min(), vmax=z.max())

    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')

    # Applique la colormap personnalisée avec normalisation
    surf = ax.plot_surface(x, y, z,cmap=cmap) # cmap=cmap, norm=norm

    # Ajoute une barre de couleur pour illustrer les valeurs de hauteur
    fig.colorbar(surf, ax=ax, shrink=0.5, aspect=5, label='Hauteur')

    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Hauteur')
    ax.set_title('Paysage 3D')

    plt.show()

def dijkstra(final_landscape):
    rows, cols = final_landscape.shape
    distance = np.zeros((rows, cols))
    visited = np.zeros((rows, cols), dtype=bool)
    visited[0, 0] = True

    for i in range(1, rows):
        distance[i, 0] = distance[i-1, 0] + final_landscape[i, 0]

    for j in range(1, cols):
        distance[0, j] = distance[0, j-1] + final_landscape[0, j]

    for i in range(1, rows):
        for j in range(1, cols):
            distance[i, j] = final_landscape[i, j] + min(distance[i-1, j], distance[i, j-1])

    return distance

def find_optimal_path(distance):
    rows, cols = distance.shape   # dimensions du paysage
    path = [(rows - 1, cols - 1)]
    i, j = rows - 1, cols - 1

    while (i, j) != (0, 0):
        if i > 0 and distance[i - 1, j] <= distance[i, j - 1]:
            i -= 1
        elif j > 0 and distance[i, j - 1] <= distance[i - 1, j]:
            j -= 1
        else:
            break
        path.append((i, j))

    path.reverse()
    return path

def plot_dijkstra(final_landscape, path):
    rows, cols = final_landscape.shape
    x = np.arange(rows)
    y = np.arange(cols)
    x, y = np.meshgrid(x, y)

    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')

    ax.plot_surface(x, y, final_landscape, cmap='terrain', alpha=0.7)

    path_x, path_y = zip(*path)
    path_z = final_landscape[path_x, path_y]
    ax.plot(path_x, path_y, path_z, color='red', linewidth=2, marker='o', markersize=5, markerfacecolor='red')

    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Hauteur')
    ax.set_title('Paysage 3D avec Chemin Optimal')

    plt.show()

rows, cols = 100, 100
landscape = generate_initial_landscape(rows, cols)
smoothed_landscape = smooth_landscape(landscape)
final_landscape_matrix = final_landscape(smoothed_landscape)

save_landscape_to_csv(final_landscape_matrix, 'final_landscape_matrix_100x100.csv')

plot_landscape_3d(final_landscape_matrix)

distance_matrix = dijkstra(final_landscape_matrix)
optimal_path = find_optimal_path(distance_matrix)
plot_dijkstra(final_landscape_matrix, optimal_path)
